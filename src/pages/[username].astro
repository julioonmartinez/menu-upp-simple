---
// src/pages/[username].astro
import ProfileLayout from '../layouts/ProfileLayout.astro';
import ProfileHeader from '../components/ProfileHeader.astro';
import SocialLinks from '../components/SocialLinks.astro';
import LinkCard from '../components/LinkCard.astro';
import CTAButton from '../components/CTAButton.astro';

// Import services and mock data
import { fetchRestaurantProfile, checkApiHealth } from '../services/apiService';
import { getMockRestaurantProfile } from '../data/mockData';
import type { Restaurant, LinkTree, Link } from '../interfaces';

// export async function getStaticPaths() {
//   // Para desarrollo y producci√≥n, generar paths est√°ticos
//   // En el futuro esto se podr√≠a obtener de la API
//   const mockUsernames = ['labellavita', 'tacoselrey', 'sushizen'];
  
//   return mockUsernames.map(username => ({
//     params: { username }
//   }));
// }

interface Props {
  restaurant: Restaurant;
  linkTree: LinkTree;
}

const { username } = Astro.params;

let restaurant: Restaurant;
let linkTree: LinkTree;
let dataSource = 'unknown';

try {
  // Verificar si debemos forzar mock data
  const forceMockData = import.meta.env.PUBLIC_USE_MOCK_DATA === 'true';
  
  if (forceMockData) {
    console.log(`üîß Using forced mock data for: ${username}`);
    const mockData = getMockRestaurantProfile(username!);
    restaurant = mockData.restaurant;
    linkTree = mockData.linkTree;
    dataSource = 'mock-forced';
  } else {
    // Intentar usar la API real
    try {
      console.log(`üåê Attempting to fetch from API: ${username}`);
      
      const data = await fetchRestaurantProfile(username!);
      restaurant = data.restaurant;
      linkTree = data.linkTree;
      dataSource = 'api';
      
      console.log(`‚úÖ Successfully fetched from API: ${username}`);
    } catch (apiError) {
      console.warn(`‚ö†Ô∏è API failed for ${username}, falling back to mock data:`, apiError);
      
      // Fallback a mock data si la API falla
      const mockData = getMockRestaurantProfile(username!);
      restaurant = mockData.restaurant;
      linkTree = mockData.linkTree;
      dataSource = 'mock-fallback';
    }
  }
} catch (error) {
  console.error('‚ùå Error loading restaurant profile:', error);
  // Return 404 if no data available (ni API ni mock data)
  return Astro.redirect('/404');
}

// Verificar que el perfil est√© p√∫blico
if (!linkTree.isPublic) {
  return Astro.redirect('/404');
}

// Filtrar y ordenar links activos
const activeLinks = linkTree.links
  .filter((link: Link) => link.active)
  .sort((a: Link, b: Link) => a.order - b.order);

// Configurar tema para componentes
const socialTheme = {
  backgroundColor: linkTree.socialMediaBackgroundColor || restaurant.primaryColor,
  textColor: linkTree.socialMediaTextColor
};

const linkTheme = {
  backgroundColor: linkTree.linksBackgroundColor,
  textColor: linkTree.linksColor
};

const ctaTheme = {
  backgroundColor: linkTree.ctaBackgroundColor || restaurant.primaryColor,
  textColor: linkTree.ctaTextColor
};
---

<ProfileLayout restaurant={restaurant} linkTree={linkTree}>
  <main class="profile-content">
    <!-- Header con imagen, perfil, nombre y ubicaci√≥n -->
    <ProfileHeader restaurant={restaurant} linkTree={linkTree} />
    
    <!-- Redes sociales -->
    <SocialLinks socialLinks={restaurant.socialLinks} theme={socialTheme} />
    
    <!-- Enlaces principales -->
    {activeLinks.length > 0 && (
      <div class="main-links">
        {activeLinks.map((link: Link) => (
          <LinkCard link={link} theme={linkTheme} />
        ))}
      </div>
    )}
    
    <!-- Call to Action -->
    <!-- <CTAButton restaurant={restaurant} theme={ctaTheme} /> -->
    
    <!-- Data Source Indicator (solo en desarrollo) -->
    {import.meta.env.DEV && (
      <div class="data-source-indicator">
        <span class={`source-badge source-${dataSource}`}>
          {dataSource === 'api' && 'üåê API'}
          {dataSource === 'mock-forced' && 'üîß Mock (Forced)'}
          {dataSource === 'mock-fallback' && '‚ö†Ô∏è Mock (Fallback)'}
        </span>
      </div>
    )}
    
    <!-- Informaci√≥n adicional -->
    {(restaurant.cuisineType || restaurant.features) && (
      <div class="additional-info">
        {restaurant.cuisineType && restaurant.cuisineType.length > 0 && (
          <div class="info-section">
            <h3 class="info-title">Tipo de cocina</h3>
            <div class="info-tags">
              {restaurant.cuisineType.map(cuisine => (
                <span class="info-tag">{cuisine}</span>
              ))}
            </div>
          </div>
        )}
        
        {restaurant.features && restaurant.features.length > 0 && (
          <div class="info-section">
            <h3 class="info-title">Servicios</h3>
            <div class="info-tags">
              {restaurant.features.map(feature => (
                <span class="info-tag">
                  {feature === 'delivery' ? 'üöö Domicilio' :
                   feature === 'takeaway' ? 'ü•° Para llevar' :
                   feature === 'outdoor_seating' ? 'üåø Terraza' :
                   feature}
                </span>
              ))}
            </div>
          </div>
        )}
      </div>
    )}
  </main>
</ProfileLayout>

<style>
  .profile-content {
    padding: 0 0 2rem 0;
  }
  
  .main-links {
    display: flex;
    flex-direction: column;
    gap: 0.75rem;
    padding: 0 1.5rem;
    margin-bottom: 1rem;
  }
  
  .additional-info {
    padding: 0 1.5rem;
    margin-top: 2rem;
  }
  
  .info-section {
    margin-bottom: 1.5rem;
  }
  
  .info-title {
    font-size: 0.9rem;
    font-weight: 600;
    color: var(--text-color);
    margin-bottom: 0.75rem;
    opacity: 0.8;
  }
  
  .info-tags {
    display: flex;
    flex-wrap: wrap;
    gap: 0.5rem;
  }
  
  .info-tag {
    display: inline-block;
    padding: 0.375rem 0.75rem;
    background-color: rgba(255, 69, 0, 0.1);
    color: var(--primary-color);
    border-radius: 50px;
    font-size: 0.8rem;
    font-weight: 500;
    border: 1px solid rgba(255, 69, 0, 0.2);
  }
  
  /* Animaciones espec√≠ficas para esta p√°gina */
  .main-links > * {
    opacity: 0;
    transform: translateY(15px);
    animation: fadeInUp 0.6s ease forwards;
  }
  
  .main-links > *:nth-child(1) { animation-delay: 0.1s; }
  .main-links > *:nth-child(2) { animation-delay: 0.2s; }
  .main-links > *:nth-child(3) { animation-delay: 0.3s; }
  .main-links > *:nth-child(4) { animation-delay: 0.4s; }
  .main-links > *:nth-child(5) { animation-delay: 0.5s; }
  
  /* Data source indicator (desarrollo) */
  .data-source-indicator {
    position: fixed;
    bottom: 1rem;
    right: 1rem;
    z-index: 1000;
  }
  
  .source-badge {
    display: inline-block;
    padding: 0.5rem 1rem;
    border-radius: 50px;
    font-size: 0.75rem;
    font-weight: 600;
    color: white;
    box-shadow: 0 4px 12px rgba(0,0,0,0.2);
  }
  
  .source-api {
    background-color: #22C55E;
  }
  
  .source-mock-forced {
    background-color: #3B82F6;
  }
  
  .source-mock-fallback {
    background-color: #F59E0B;
  }
  
  @keyframes fadeInUp {
    to {
      opacity: 1;
      transform: translateY(0);
    }
  }
  
  @media (max-width: 480px) {
    .main-links {
      padding: 0 1rem;
      gap: 0.5rem;
    }
    
    .additional-info {
      padding: 0 1rem;
    }
    
    .info-tag {
      font-size: 0.75rem;
      padding: 0.25rem 0.5rem;
    }
  }
</style>

